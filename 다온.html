<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Îã§Ïò® vs Ïú†Ï£º: Ï†ÄÏä§Ìä∏ Í∞ÄÎìú & Îã§Ïù¥ÎÇòÎØπ Ïπ¥Î©îÎùº</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap');

        body {
            background-color: #1a1a1a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; margin: 0; color: white; overflow: hidden;
            font-family: 'Black Han Sans', sans-serif;
        }
        
        .game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 210, 255, 0.3);
            border-radius: 20px;
        }

        canvas {
            border: 8px solid #fff; border-radius: 20px;
            background: #1e3c72;
            display: block;
        }

        .ui-layer {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            text-shadow: 3px 3px 0 #000;
        }

        /* ‚ñº‚ñº‚ñº [Ï∂îÍ∞ÄÎêú Î≤ÑÌäº Ïä§ÌÉÄÏùº] ‚ñº‚ñº‚ñº */
        .home-btn {
            position: absolute;
            top: 10px; 
            left: 30px;
            padding: 10px 25px;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 1.5rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.5); /* Î∞òÌà¨Î™Ö Î∞∞Í≤Ω */
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px; /* Îë•Í∑º Ï∫°Ïäê Î™®Ïñë */
            cursor: pointer;
            z-index: 100;
            pointer-events: auto; /* Î∂ÄÎ™®Ïùò none ÏÜçÏÑ± Î¨¥ÏãúÌïòÍ≥† ÌÅ¥Î¶≠ Í∞ÄÎä• */
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-shadow: 2px 2px 0 #000;
        }

        .home-btn:hover {
            background-color: #ff5e62; /* Ìò∏Î≤Ñ Ïãú ÎÑ§Ïò® ÌïëÌÅ¨/Î†àÎìú Í≥ÑÏó¥ */
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px #ff5e62;
        }

        .home-btn:active {
            transform: scale(0.95);
        }
        /* ‚ñ≤‚ñ≤‚ñ≤ [Ï∂îÍ∞ÄÎêú Î≤ÑÌäº Ïä§ÌÉÄÏùº ÎÅù] ‚ñ≤‚ñ≤‚ñ≤ */

        .score-box {
            font-size: 4rem; color: #fff;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 40px; border-radius: 50px;
            display: inline-block;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        .score-p1, .score-p2 {
            display: inline-block;
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275), color 0.1s;
        }
        .score-p1 { color: #00d2ff; }
        .score-p2 { color: #ff5e62; }
        
        #item-notice {
            position: absolute; top: 180px; width: 100%;
            text-align: center; font-size: 3.5rem; color: yellow;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 red; 
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            z-index: 10;
        }

        .controls {
            margin-top: 20px; width: 1400px;
            padding: 15px 0;
            background: linear-gradient(135deg, #141e30 0%, #243b55 100%);
            border-radius: 15px; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        .key-row {
            font-size: 1.3rem; margin-bottom: 10px; color: #ddd;
            text-shadow: 1px 1px 2px #000;
        }

        .key-btn {
            display: inline-block; padding: 2px 8px;
            border: 2px solid #aaa; border-radius: 6px;
            background: rgba(255,255,255,0.15);
            font-family: monospace; font-weight: bold; color: #fff;
            box-shadow: 0 3px 0 #555;
            margin: 0 2px;
        }

        .smash-row {
            font-size: 1.8rem; color: #FFD700;
            margin-top: 5px;
            text-shadow: 0 0 10px #FF4500, 2px 2px 0 #000;
            animation: pulseText 1.5s ease-in-out infinite;
        }
        
        .mode-indicator {
            position: absolute; bottom: 20px; right: 20px;
            font-size: 1.5rem; color: #00FF00;
            text-shadow: 0 0 5px #000;
            font-family: Arial, sans-serif;
        }

        @keyframes pulseText {
            0% { transform: scale(1); text-shadow: 0 0 10px #FF4500; }
            50% { transform: scale(1.05); text-shadow: 0 0 20px #FF0000, 0 0 30px #FFFF00; }
            100% { transform: scale(1); text-shadow: 0 0 10px #FF4500; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="ui-layer">
            <button class="home-btn" onclick="location.href='index.html'">
                üè† Î©îÏù∏ÏúºÎ°ú
            </button>
            <div class="score-box">
                <span class="score-p1" id="scoreP1">0</span> : <span class="score-p2" id="scoreP2">0</span>
            </div>
            <div id="item-notice"></div>
        </div>
        <canvas id="gameCanvas" width="1400" height="800"></canvas>
        <div id="modeDisplay" class="mode-indicator"></div>
    </div>

    <div class="controls">
        <div class="key-row">
            <span style="color:#00d2ff">P1</span>: 
            <span class="key-btn">W</span><span class="key-btn">A</span><span class="key-btn">D</span> Ïù¥Îèô 
            + <span class="key-btn" style="border-color:#00d2ff; color:#00d2ff">S</span> Ïä§Îß§Ïãú
            &nbsp;&nbsp;|&nbsp;&nbsp; 
            <span style="color:#ff5e62">P2 (AI)</span>: 
            <span id="p2-control-text">ÏûêÎèô ÌîåÎ†àÏù¥ Ï§ë... ü§ñ</span>
        </div>
        <div class="smash-row">
            ‚òÖ S(‚Üì)ÌÇ§Î°ú ÌÉÄÏù¥Î∞ç ÎßûÏ∂∞ Î∞©Ïñ¥ÌïòÎ©¥ 'Ï†ÄÏä§Ìä∏ Í∞ÄÎìú' Î∞úÎèô! ‚òÖ
        </div>
    </div>

    <script>
        // --- [AI Ïª®Ìä∏Î°§Îü¨] ---
        class AIController {
            constructor() {
                this.targetX = 1050; 
                this.predictionX = 1050;
                this.reactionTimer = 0;
            }

            update(p2, ball, netH) {
                keys[p2.controls.left] = false;
                keys[p2.controls.right] = false;
                keys[p2.controls.up] = false;
                keys[p2.controls.down] = false;

                if (gameState !== 'playing' || cinematicTimer > 0) return;
                if (ball.isRising || ball.isHolding) return;

                const ballInMySide = ball.x > 700; 
                const ballComing = ball.vx > 0; 
                
                if (ballComing || ballInMySide) {
                    let timeToLand = 0;
                    if(ball.vy !== 0) {
                        timeToLand = (GROUND_Y - ball.y) / (Math.abs(ball.vy) + 1);
                    } else {
                        timeToLand = 20;
                    }
                    
                    let expectedX = ball.x + (ball.vx * timeToLand);
                    if (expectedX > 1400) expectedX = 1400 - (expectedX - 1400);
                    if (expectedX < 700) expectedX = 700; 

                    this.predictionX = expectedX;
                    this.targetX = this.predictionX + 20; 
                } else {
                    this.targetX = 1050; 
                }

                if (this.targetX < 750) this.targetX = 750;

                const margin = 15; 
                const myX = p2.x + DISPLAY_W/2;

                if (myX < this.targetX - margin) {
                    keys[p2.controls.right] = true;
                } else if (myX > this.targetX + margin) {
                    keys[p2.controls.left] = true;
                }

                const distX = Math.abs(myX - ball.x);
                const ballHeight = ball.y;

                if (ballInMySide && distX < 80 && ballHeight < p2.y && ballHeight > 100) {
                     if (!p2.isJumping) {
                         keys[p2.controls.up] = true;
                     }
                }

                if (p2.isJumping) {
                    if (ball.y < p2.y + 50 && distX < 60) {
                        keys[p2.controls.down] = true; 
                    }
                }
                // Ï†ÄÏä§Ìä∏ Í∞ÄÎìú AI (Í≥µÏù¥ Îπ†Î•¥Í≥† Í∞ÄÍπåÏö∏ Îïå)
                if (ballInMySide && (ball.isSuperSmash || ball.isFireShot) && distX < 60 && ballHeight > p2.y - 50) {
                     keys[p2.controls.down] = true; 
                }
            }
        }
        // ------------------------------------

        // ‚òÖ [1. Îã§Ïù¥ÎÇòÎØπ Ïπ¥Î©îÎùº Í∞ùÏ≤¥]
        const camera = {
            x: 0,
            y: 0,
            zoom: 1,
            update: function(ball) {
                let targetZ = 1.0;
                let targetX = 0;
                let targetY = 0;

                // Ïï°ÏÖò ÏÉÅÌô©(Ïä§Îß§Ïãú, Î∂àÍΩÉÏäõ, ÌïÑÏÇ¥Í∏∞ ÏãúÏ†Ñ Îì±)ÏóêÏÑú Ï§åÏù∏
                if (ball.isSuperSmash || ball.isFireShot || ball.isRising || ball.isHolding) {
                    targetZ = 1.15; // 1.15Î∞∞ Ï§åÏù∏
                    // Ïπ¥Î©îÎùºÎäî Í≥µÏùÑ ÏïΩÍ∞Ñ Îî∞ÎùºÍ∞ê (Ï†úÌïúÏ†Å)
                    targetX = (700 - ball.x) * 0.2; 
                    targetY = (400 - ball.y) * 0.2;
                } else {
                    targetZ = 1.0;
                    targetX = 0;
                    targetY = 0;
                }

                // Î∂ÄÎìúÎü¨Ïö¥ Ï†ÑÌôò (Linear Interpolation)
                this.zoom += (targetZ - this.zoom) * 0.05;
                this.x += (targetX - this.x) * 0.05;
                this.y += (targetY - this.y) * 0.05;
            },
            apply: function(ctx) {
                // ÌôîÎ©¥ Ï§ëÏã¨ Í∏∞Ï§ÄÏúºÎ°ú Ï§åÏù∏
                ctx.translate(700, 400);
                ctx.scale(this.zoom, this.zoom);
                ctx.translate(-700 + this.x, -400 + this.y);
            }
        };

        // CLASS DEFINITIONS
        class Reaction {
            constructor(x, y, emoji) {
                this.x = x; this.y = y; this.emoji = emoji;
                this.life = 60; this.vy = -2;
            }
            update() { this.y += this.vy; this.life--; }
            draw() {
                if(this.life <= 0) return;
                ctx.save(); ctx.globalAlpha = this.life / 60;
                ctx.font = "50px Arial"; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.restore();
            }
        }

        class HitText {
            constructor(x, y, text, color) {
                this.x = x; this.y = y;
                this.text = text; this.color = color;
                this.life = 40; 
                this.size = 40; 
                this.rotation = (Math.random() - 0.5) * 0.5; 
            }
            update() {
                this.y -= 1.5; this.life--; this.size += 0.2;
            }
            draw() {
                if(this.life <= 0) return;
                ctx.save(); 
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life / 40;
                ctx.font = `bold ${this.size}px 'Black Han Sans', sans-serif`;
                ctx.textAlign = "center"; ctx.fillStyle = this.color;
                ctx.strokeStyle = "white"; ctx.lineWidth = 4;
                ctx.strokeText(this.text, 0, 0);
                ctx.fillText(this.text, 0, 0);
                ctx.restore();
            }
        }

        class Confetti {
            constructor() {
                this.x = Math.random() * 1400; this.y = Math.random() * -800;
                this.vx = (Math.random() - 0.5) * 4; this.vy = Math.random() * 5 + 3;
                this.color = `hsl(${Math.random()*360}, 100%, 50%)`;
                this.size = Math.random() * 15 + 5;
                this.rotation = Math.random() * 360; this.rotationSpeed = (Math.random() - 0.5) * 10;
            }
            update() { this.y += this.vy; this.x += this.vx; this.rotation += this.rotationSpeed; if(this.y > 800) this.y = -50; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation * Math.PI / 180);
                ctx.fillStyle = this.color; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); ctx.restore();
            }
        }

        class Dust {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2 - 1; 
                this.size = Math.random() * 8 + 4;
                this.life = 1.0;
                this.color = `rgba(200, 190, 180, 0.6)`; 
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.05; this.size *= 0.95;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class InkSplotch {
            constructor() {
                this.x = Math.random() * 1400;
                this.y = Math.random() * 800;
                this.size = Math.random() * 100 + 150;
                this.life = 420; 
                this.scale = 0;
                this.maxScale = 1;
            }
            update() {
                if (this.scale < this.maxScale) this.scale += 0.1;
                this.life--;
            }
            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = Math.min(1, this.life / 60);
                ctx.fillStyle = "black";
                ctx.beginPath(); ctx.arc(0, 0, this.size/2, 0, Math.PI * 2); ctx.fill();
                for(let i=0; i<5; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.cos(i)*this.size/2, Math.sin(i)*this.size/2, this.size/5, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class FakeBall {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = 0; this.vy = 0;
                this.radius = BALL_R; this.color = color;
                this.active = true;
                this.trail = [];
            }
            update() {
                if (!this.active) return;
                this.vy += GRAVITY; this.x += this.vx; this.y += this.vy;
                
                this.trail.push({x: this.x, y: this.y, r: this.radius * 0.8});
                if(this.trail.length > 10) this.trail.shift();

                if (this.x < this.radius || this.x > 1400 - this.radius) this.vx *= -0.8;
                if (this.y > GROUND_Y - this.radius) {
                    this.active = false; createExplosion(this.x, this.y, this.color); 
                }
                if(Math.random() < 0.3) particles.push(new Particle(this.x, this.y, "#FF4500", true));
            }
            draw() {
                if (!this.active) return;
                
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let t of this.trail) ctx.lineTo(t.x, t.y);
                    ctx.strokeStyle = "rgba(255, 69, 0, 0.5)";
                    ctx.lineWidth = 15;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.color; ctx.globalAlpha = 0.8; ctx.fill(); 
                ctx.lineWidth = 4; ctx.strokeStyle = "#333"; ctx.stroke();
                
                ctx.shadowBlur = 20; ctx.shadowColor = "red";
                ctx.beginPath(); ctx.arc(this.x - 10, this.y - 10, 8, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255,255,255,0.6)"; ctx.fill(); 
                ctx.shadowBlur = 0;
            }
        }

        class Item {
            constructor() {
                this.x = Math.random() * (1400 - 100) + 50; 
                this.y = -50; 
                this.vy = 2.5; 
                this.size = 40; 
                this.active = true;
                
                const rand = Math.random();
                if (rand < 0.08) this.type = 'FIRE'; 
                else if (rand < 0.13) this.type = 'BANANA'; 
                else if (rand < 0.18) this.type = 'POOP'; 
                else if (rand < 0.23) this.type = 'ICE';  
                else if (rand < 0.28) this.type = 'CONFUSION'; 
                else if (rand < 0.33) this.type = 'GIANT'; 
                else if (rand < 0.38) this.type = 'DWARF'; 
                else if (rand < 0.43) this.type = 'SPEED'; 
                else if (rand < 0.48) this.type = 'JUMP'; 
                else if (rand < 0.53) this.type = 'BIG'; 
                else if (rand < 0.58) this.type = 'BONUS';
                else if (rand < 0.63) this.type = 'BOMB';     
                else if (rand < 0.68) this.type = 'BLACKOUT'; 
                else if (rand < 0.73) this.type = 'TYPHOON';  
                else if (rand < 0.78) this.type = 'GHOST';
                else if (rand < 0.83) this.type = 'INK'; 
                else if (rand < 0.88) this.type = 'CLONE';
                else if (rand < 0.93) this.type = 'WALL';
                else this.type = 'CHICKEN';
            }
            
            draw() {
                if (!this.active) return;
                let icon = ""; let bgColor = ""; let borderColor = "white";
                
                if (this.type === 'FIRE') { icon = "üî•"; bgColor = "#FF4500"; borderColor = "#FFFF00"; }
                else if (this.type === 'BANANA') { icon = "üçå"; bgColor = "#FFFF00"; borderColor = "#FFA500"; }
                else if (this.type === 'POOP') { icon = "üí©"; bgColor = "#8B4513"; borderColor = "#A0522D"; }
                else if (this.type === 'GIANT') { icon = "üçÑ"; bgColor = "#FF0000"; borderColor = "#FFFFFF"; }
                else if (this.type === 'DWARF') { icon = "üë∂"; bgColor = "#87CEEB"; borderColor = "#0000FF"; }
                else if (this.type === 'ICE') { icon = "‚ùÑÔ∏è"; bgColor = "#00BFFF"; borderColor = "#FFFFFF"; }
                else if (this.type === 'CONFUSION') { icon = "üòµ"; bgColor = "#8A2BE2"; borderColor = "#FF00FF"; }
                else if (this.type === 'SPEED') { icon = "‚ö°"; bgColor = "#0044FF"; borderColor = "#00FFFF"; }
                else if (this.type === 'JUMP') { icon = "üöÄ"; bgColor = "#00aa00"; borderColor = "#00FF00"; }
                else if (this.type === 'BIG') { icon = "üèê"; bgColor = "#FF6347"; borderColor = "#FFaaaa"; }
                else if (this.type === 'BONUS') { icon = "üíé"; bgColor = "#6600CC"; borderColor = "#EE82EE"; }
                else if (this.type === 'BOMB') { icon = "üí£"; bgColor = "#333333"; borderColor = "#FF0000"; }
                else if (this.type === 'BLACKOUT') { icon = "üåë"; bgColor = "#000000"; borderColor = "#555555"; }
                else if (this.type === 'TYPHOON') { icon = "üå™Ô∏è"; bgColor = "#AAAAAA"; borderColor = "#FFFFFF"; }
                else if (this.type === 'GHOST') { icon = "üëª"; bgColor = "#FFFFFF"; borderColor = "#AAAAAA"; }
                else if (this.type === 'INK') { icon = "ü¶ë"; bgColor = "#000000"; borderColor = "#444444"; }
                else if (this.type === 'CLONE') { icon = "ü§•"; bgColor = "#FF69B4"; borderColor = "#FFFFFF"; }
                else if (this.type === 'WALL') { icon = "üß±"; bgColor = "#8B4513"; borderColor = "#CCCCCC"; }
                else if (this.type === 'CHICKEN') { icon = "üêî"; bgColor = "#FFD700"; borderColor = "#FF0000"; }

                ctx.save(); ctx.translate(this.x, this.y);
                ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI * 2); ctx.fillStyle = borderColor; ctx.fill();
                ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI * 2); ctx.fillStyle = bgColor; ctx.fill();
                ctx.font = "35px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "white";
                ctx.fillText(icon, 0, 2); ctx.restore();
            }
            update() { if (!this.active) return; this.y += this.vy; if (this.y > GROUND_Y) this.active = false; }
        }

        class Particle {
            constructor(x, y, color, isSmoke = false) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 15; 
                this.vy = (Math.random() - 0.5) * 15;
                this.life = 1.0; this.color = color; 
                this.isSmoke = isSmoke;
                this.size = Math.random() * 10 + 5; 
                if (isSmoke) {
                    this.vx *= 0.5; this.vy = -Math.random() * 3 - 1; // Ïó∞Í∏∞Îäî ÏúÑÎ°ú
                    this.size *= 1.5;
                    this.life = 0.8;
                }
            }
            update() { 
                this.x += this.vx; this.y += this.vy; 
                this.life -= 0.02; 
                this.size *= 0.96; 
            }
            draw() { 
                ctx.save();
                ctx.globalCompositeOperation = this.isSmoke ? 'source-over' : 'lighter'; 
                ctx.globalAlpha = this.life; 
                ctx.fillStyle = this.color; 
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); 
                ctx.restore();
            }
        }

        class Shockwave {
            constructor(x, y, color) { this.x = x; this.y = y; this.radius = 20; this.alpha = 1.0; this.lineWidth = 15; this.color = color; }
            update() { this.radius += 20; this.alpha -= 0.05; this.lineWidth *= 0.9; }
            draw() { if (this.alpha <= 0) return; ctx.save(); ctx.globalAlpha = this.alpha; ctx.strokeStyle = this.color; ctx.lineWidth = this.lineWidth; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }
        }

        class Player {
            constructor(x, charInfo, controls, side) {
                this.x = x; this.y = GROUND_Y - DISPLAY_H;
                this.vx = 0; this.vy = 0;
                this.name = charInfo.name; 
                this.img = charInfo.img;
                this.frames = charInfo.frames;
                this.controls = controls;
                this.side = side;
                this.isJumping = false;
                
                this.baseSpeed = charInfo.stats.speed;
                this.baseJumpForce = charInfo.stats.jump;
                this.jumpForce = this.baseJumpForce;
                this.power = charInfo.stats.power; 
                this.moveSpeed = this.baseSpeed;

                this.gauge = 0;
                this.maxGauge = 100;
                
                this.isJumpSmash = false;
                this.isSmashHit = false;
                this.chickenTimer = 0;
                
                this.emoji = "";
                this.emojiTimer = 0;

                this.scale = 1.0;
                this.angle = 0;
                this.stunTimer = 0;
                this.poopTimer = 0;
                this.frozenTimer = 0; 
                this.confusedTimer = 0; 
                this.hasJumpBuff = false; 
                
                this.fireMultiBallTimer = 0;
            }
            
            setEmoji(emoji) {
                this.emoji = emoji;
                this.emojiTimer = 120; 
            }

            update() {
                if (gameState === 'gameover') {
                    if (this.y < GROUND_Y - DISPLAY_H) { this.vy += GRAVITY; this.y += this.vy; }
                    else { this.y = GROUND_Y - DISPLAY_H; }
                    if (this.side === winnerSide) {
                        if(frameCount % 40 === 0) { this.vy = -8; }
                        this.y += this.vy;
                    } 
                    return;
                }

                if (gameState !== 'playing') return;
                
                if (cinematicTimer > 0) return;

                if (this.chickenTimer > 0) this.chickenTimer--; 
                
                if (this.emojiTimer > 0) {
                    this.emojiTimer--;
                } else {
                    this.emoji = "";
                }

                if (this.fireMultiBallTimer > 0) this.fireMultiBallTimer--;

                if (this.frozenTimer > 0) {
                    this.frozenTimer--;
                    this.vx = 0; 
                    this.vy += GRAVITY; 
                    this.y += this.vy;
                    if(this.y > GROUND_Y - DISPLAY_H) { this.y = GROUND_Y - DISPLAY_H; this.vy = 0; }
                    return; 
                }

                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    
                    if (this.isSmashHit) {
                        this.angle += 0.5; 
                    } else {
                        this.angle += 0.3; 
                    }

                    this.vx *= 0.9; 
                    this.vy += GRAVITY; 
                    this.y += this.vy;
                    if(this.y > GROUND_Y - DISPLAY_H) { this.y = GROUND_Y - DISPLAY_H; this.vy = 0; }
                    this.x += this.vx; 
                    const wallOffset = 80;
                    if (this.side === 'left') this.x = Math.max(-wallOffset, Math.min(this.x, 700 - DISPLAY_W + 50));
                    else this.x = Math.max(700 - 50, Math.min(this.x, 1400 - DISPLAY_W + wallOffset));
                    
                    if (this.stunTimer <= 0) {
                        this.angle = 0;
                        this.isSmashHit = false; 
                    }
                    return; 
                } else { this.angle = 0; }

                let currentSpeed = this.moveSpeed;
                
                if (typhoonTimer > 0) {
                    this.vx += windDirection * 0.8; 
                }

                if (this.poopTimer > 0) {
                    this.poopTimer--;
                    currentSpeed = this.baseSpeed * 0.3; 
                }
                
                let leftKey = keys[this.controls.left];
                let rightKey = keys[this.controls.right];
                
                if (this.confusedTimer > 0) {
                    this.confusedTimer--;
                    let temp = leftKey; leftKey = rightKey; rightKey = temp;
                }

                if (leftKey) this.vx = -currentSpeed;
                if (rightKey) this.vx = currentSpeed;
                
                if (Math.abs(this.vx) > 1.5 && this.y >= GROUND_Y - DISPLAY_H) {
                    if (Math.random() < 0.3) {
                        dusts.push(new Dust(this.x + DISPLAY_W/2, this.y + DISPLAY_H));
                    }
                }

                if (keys[this.controls.up] && !this.isJumping) { 
                    this.vy = this.jumpForce; 
                    this.isJumping = true; 
                    if (this.hasJumpBuff) {
                        jumpSound.currentTime = 0;
                        jumpSound.play().catch(()=>{});
                    }
                }
                this.vy += GRAVITY; this.vx *= FRICTION;
                this.x += this.vx; this.y += this.vy;
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                
                if (this.y > GROUND_Y - DISPLAY_H) { 
                    if (this.isJumping) { 
                        for(let k=0; k<8; k++) {
                            dusts.push(new Dust(this.x + DISPLAY_W/2, GROUND_Y));
                        }
                    }
                    this.y = GROUND_Y - DISPLAY_H; this.vy = 0; this.isJumping = false; 
                }
                
                const wallOffset = 80;
                if (this.side === 'left') this.x = Math.max(-wallOffset, Math.min(this.x, 700 - DISPLAY_W + 50));
                else this.x = Math.max(700 - 50, Math.min(this.x, 1400 - DISPLAY_W + wallOffset));
            }
            draw() {
                ctx.save();
                const barW = 80; const barH = 10;
                const barX = this.x + DISPLAY_W/2 - barW/2;
                const barY = this.y - 65; 
                const isMax = this.gauge >= 100;

                ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(barX, barY, barW, barH);
                const fillW = (this.gauge / this.maxGauge) * barW;
                
                if (isMax) {
                    const hue = (Date.now() / 2) % 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; 
                    ctx.shadowBlur = 15; ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
                    if (Math.floor(Date.now() / 100) % 2 === 0) {
                        ctx.font = "bold 24px 'Black Han Sans', sans-serif";
                        ctx.textAlign = "center"; ctx.fillStyle = "#FFD700"; 
                        ctx.strokeStyle = "red"; ctx.lineWidth = 3;
                        ctx.strokeText("MAX!", this.x + DISPLAY_W/2, barY - 8);
                        ctx.fillText("MAX!", this.x + DISPLAY_W/2, barY - 8);
                    }
                } else {
                    ctx.fillStyle = "yellow"; ctx.shadowBlur = 0;
                }
                ctx.fillRect(barX, barY, fillW, barH);
                ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(barX, barY, barW, barH);
                ctx.restore();

                if (this.emojiTimer > 0 && this.emoji) {
                    ctx.save();
                    ctx.font = "bold 50px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "white";
                    ctx.shadowBlur = 10; ctx.shadowColor = "black";
                    const floatY = Math.sin(Date.now() / 100) * 5;
                    ctx.fillText(this.emoji, this.x + DISPLAY_W/2, this.y - 100 + floatY);
                    ctx.restore();
                }

                let statusIcon = "";
                if (this.isSmashHit || this.stunTimer > 0) statusIcon = "üí´";
                else if (this.frozenTimer > 0) statusIcon = "‚ùÑÔ∏è";
                else if (this.poopTimer > 0) statusIcon = "ü™∞";
                else if (this.confusedTimer > 0) statusIcon = "üòµ";
                else if (this.fireMultiBallTimer > 0) statusIcon = "üî•";
                else if (this.moveSpeed > this.baseSpeed) statusIcon = "‚ö°";

                if (statusIcon) {
                    ctx.save();
                    ctx.font = "bold 40px Arial"; ctx.textAlign = "center";
                    ctx.fillText(statusIcon, this.x + DISPLAY_W/2, this.y - 85 + Math.sin(frameCount/8)*5);
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(this.x + DISPLAY_W/2, this.y + DISPLAY_H/2);
                ctx.rotate(this.angle);
                ctx.scale(this.scale, this.scale);
                
                if (isMax) { ctx.shadowColor = "rgba(255, 255, 0, 0.8)"; ctx.shadowBlur = 20; }
                if (this.poopTimer > 0) { ctx.filter = "sepia(1) hue-rotate(-50deg) saturate(3)"; ctx.font = "40px Arial"; ctx.fillText("üí©", 0, -80); }
                
                if (this.frozenTimer > 0) {
                    ctx.filter = "hue-rotate(180deg) brightness(1.5)"; 
                    ctx.font = "40px Arial"; ctx.fillText("‚ùÑÔ∏è", 0, -80);
                }

                if (this.isSmashHit) {
                     ctx.filter = "grayscale(100%)";
                } else if (this.stunTimer > 0 && !this.isSmashHit) {
                     ctx.filter = "grayscale(100%) blur(1px)";
                }

                if (this.confusedTimer > 0) {
                    const wobble = Math.sin(Date.now() / 100) * 10;
                    ctx.font = "40px Arial"; ctx.fillText("‚ùì", wobble, -80);
                }

                if (this.name === "Í∑ºÏú°Ìï†Î∞∞") {
                    ctx.save();
                    const pulse = Math.sin(frameCount * 0.1) * 0.1 + 0.9; 
                    const glowSize = 70 * pulse;
                    ctx.shadowBlur = 40; ctx.shadowColor = "rgba(255, 215, 0, 0.9)"; 
                    ctx.fillStyle = "rgba(255, 223, 0, 0.25)"; 
                    ctx.beginPath(); ctx.arc(0, 0, glowSize, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                }
                if (this.name === "ÎèàÍπåÏä§Ìï†Îß§" && keys[this.controls.down] && this.y < GROUND_Y - DISPLAY_H) {
                    ctx.save(); ctx.translate(this.x + DISPLAY_W/2, this.y + DISPLAY_H/2);
                    ctx.shadowBlur = 20; ctx.shadowColor = "red";
                    ctx.strokeStyle = `rgba(255, 69, 0, ${Math.random() * 0.5 + 0.5})`; ctx.lineWidth = 8;
                    ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = "orange";
                    for(let k=0; k<3; k++) { let lx = (Math.random()-0.5) * 100; let ly = (Math.random()-0.5) * 100; ctx.fillRect(lx, ly, 40, 4); }
                    ctx.restore();
                }

                ctx.fillStyle = "rgba(0, 0, 0, 0.3)"; ctx.beginPath();
                ctx.ellipse(0, DISPLAY_H/2 - 10, 60, 15, 0, 0, Math.PI*2); ctx.fill();
                
                const isAction = this.isJumping || keys[this.controls.down];
                const frameIdx = isAction ? this.frames[1] : this.frames[0];
                
                if (gameState === 'gameover' && this.side !== winnerSide) {
                    if (this.img && this.img.complete) { 
                        ctx.drawImage(this.img, frameIdx * FRAME_W, 0, FRAME_W, FRAME_H, -DISPLAY_W/2, -DISPLAY_H/2 + 100, DISPLAY_W, DISPLAY_H * 0.5); 
                    }
                } else {
                    if (this.chickenTimer > 0) {
                        if (images.three && images.three.complete) {
                            ctx.drawImage(images.three, 4 * FRAME_W, 0, FRAME_W, FRAME_H, -DISPLAY_W/2 - 70, -DISPLAY_H/2, DISPLAY_W, DISPLAY_H);
                            ctx.drawImage(images.three, 4 * FRAME_W, 0, FRAME_W, FRAME_H, -DISPLAY_W/2, -DISPLAY_H/2, DISPLAY_W, DISPLAY_H);
                            ctx.drawImage(images.three, 4 * FRAME_W, 0, FRAME_W, FRAME_H, -DISPLAY_W/2 + 70, -DISPLAY_H/2, DISPLAY_W, DISPLAY_H);
                        }
                    } else {
                        if (this.img && this.img.complete) { 
                            ctx.drawImage(this.img, frameIdx * FRAME_W, 0, FRAME_W, FRAME_H, -DISPLAY_W/2, -DISPLAY_H/2, DISPLAY_W, DISPLAY_H); 
                        }
                    }
                }
                ctx.restore(); 

                if (this.moveSpeed > this.baseSpeed) ctx.fillStyle = "#00FFFF"; 
                else if (this.jumpForce < this.baseJumpForce) ctx.fillStyle = "#00FF00"; 
                else if (this.poopTimer > 0) ctx.fillStyle = "#8B4513"; 
                else ctx.fillStyle = this.side === 'left' ? "#00d2ff" : "#ff5e62";
                
                ctx.font = "bold 26px 'Black Han Sans', sans-serif"; ctx.textAlign = "center";
                ctx.strokeStyle = "black"; ctx.lineWidth = 3;
                ctx.strokeText(this.name, this.x + DISPLAY_W/2, this.y - 35);
                ctx.fillText(this.name, this.x + DISPLAY_W/2, this.y - 35);
            }
        }

        class Ball {
            constructor() { 
                this.defaultColor = '#ffeb3b';
                this.smashStart = { x: 0, y: 0 };
                this.smashControl = { x: 0, y: 0 };
                this.smashEnd = { x: 0, y: 0 };
                this.smashTimer = 0;
                this.smashDuration = 0;
                this.trail = []; 
                
                this.isRising = false;  
                this.isHolding = false; 
                this.holdingTimer = 0; 
                this.fireShooter = null; 

                this.reset('left'); 
            }
            
            reset(side) {
                this.x = side === 'left' ? 350 : 1050; this.y = 200; this.vx = 0; this.vy = 0;
                this.radius = BALL_R; this.color = this.defaultColor; 
                this.mass = 1; this.mushroomCount = 0; this.isFireShot = false; 
                this.isSuperSmash = false; 
                
                this.isRising = false;
                this.isHolding = false;
                this.fireShooter = null;

                this.trail = [];
                rallyCount = 0; 
            }

            update() {
                if (gameState !== 'playing') return;
                if (cinematicTimer > 0) return; 

                if (this.isRising) {
                    const targetY = 50; 
                    const speed = 25 * GAME_SPEED_RATIO;
                    this.y = Math.max(targetY, this.y - speed);
                    
                    this.trail.push({x: this.x, y: this.y, r: Math.random() * 10 + 20}); 
                    if (this.trail.length > 25) this.trail.shift(); 
                    
                    if (Math.random() < 0.5) particles.push(new Particle(this.x, this.y, "rgba(255,100,0,0.5)"));

                    if (this.y <= targetY) {
                        this.isRising = false;
                        this.isHolding = true;
                        this.holdingTimer = 40; 
                        showItemNotice("üî• Ï∞®ÏßÄ Ï§ë...! üî•");
                    }
                    return; 
                }

                if (this.isHolding) {
                    this.holdingTimer--;
                    this.x += (Math.random() - 0.5) * 5;
                    this.y += (Math.random() - 0.5) * 5;
                    
                    for(let i=0; i<3; i++) {
                        let angle = Math.random() * Math.PI * 2;
                        let dist = 50 + Math.random() * 20;
                        let px = this.x + Math.cos(angle) * dist;
                        let py = this.y + Math.sin(angle) * dist;
                        let p = new Particle(px, py, "#FFD700");
                        p.vx = (this.x - px) * 0.1;
                        p.vy = (this.y - py) * 0.1;
                        particles.push(p);
                    }

                    if (this.holdingTimer <= 0) {
                        this.isHolding = false;
                        fireScatterShot(this); 
                    }
                    return; 
                }

                if (this.isFireShot) {
                    this.trail.push({x: this.x, y: this.y, r: this.radius * 1.2}); 
                    if (this.trail.length > 30) this.trail.shift(); 
                    particles.push(new Particle(this.x, this.y, Math.random() < 0.5 ? "#FF4500" : "#FFFF00"));
                    if(Math.random() < 0.3) particles.push(new Particle(this.x, this.y, "#333333", true)); 
                } 
                else if (this.isSuperSmash || Math.abs(this.vx) > 12 || Math.abs(this.vy) > 12) {
                    this.trail.push({x: this.x, y: this.y, r: Math.random() * 10 + 20}); 
                    if (this.trail.length > 25) this.trail.shift(); 
                } else {
                    if(this.trail.length > 0) this.trail.shift();
                }

                if (this.isSuperSmash) {
                    this.smashTimer++;
                    let t = this.smashTimer / this.smashDuration; 
                    if (t >= 1) { t = 1; this.isSuperSmash = false; }
                    let u = 1 - t;
                    this.x = (u * u * this.smashStart.x) + (2 * u * t * this.smashControl.x) + (t * t * this.smashEnd.x);
                    this.y = (u * u * this.smashStart.y) + (2 * u * t * this.smashControl.y) + (t * t * this.smashEnd.y);
                    for(let i=0; i<3; i++) particles.push(new Particle(this.x + (Math.random()-0.5)*40, this.y + (Math.random()-0.5)*40, "#FFFF00"));
                } else {
                    const currentGravity = GRAVITY * this.mass; 
                    this.vy += currentGravity; this.vx *= 0.99; 
                    if (typhoonTimer > 0) this.vx += windDirection * 0.15; 
                    this.x += this.vx; this.y += this.vy;
                }

                if (!this.isSuperSmash) {
                    if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.9; createExplosion(this.x, this.y, "white"); }
                    else if (this.x > 1400 - this.radius) { this.x = 1400 - this.radius; this.vx *= -0.9; createExplosion(this.x, this.y, "white"); }
                    const currentNetHeight = (wallTimer > 0) ? 400 : 200; 
                    if (Math.abs(this.x - 700) < this.radius + 10 && this.y > (GROUND_Y - currentNetHeight)) {
                         this.vx *= -1; netBendVel = this.vx * 1.5; 
                    }
                }

                if (this.y < this.radius) { this.y = this.radius; this.vy *= -0.8; }
                
                if (this.y > 800 - this.radius - 50) {
                    if (this.x < 700) {
                        let points = 1; if (p2.chickenTimer > 0) points = 2; 
                        score.p2 += points;
                        reactions.push(new Reaction(p2.x + DISPLAY_W/2, p2.y, "ü§£")); 
                        reactions.push(new Reaction(p1.x + DISPLAY_W/2, p1.y, "üò≠")); 
                    } else { 
                        let points = 1; if (p1.chickenTimer > 0) points = 2; 
                        score.p1 += points;
                        reactions.push(new Reaction(p1.x + DISPLAY_W/2, p1.y, "ü§£"));
                        reactions.push(new Reaction(p2.x + DISPLAY_W/2, p2.y, "üò≠"));
                    }
                    scoreP1.innerText = score.p1; scoreP2.innerText = score.p2;
                    
                    const maxScore = Math.max(score.p1, score.p2);
                    if ((maxScore === 5 && lastMaxScore < 5) || (maxScore === 10 && lastMaxScore < 10)) {
                        showItemNotice(`üåü ${maxScore}Ï†ê ÎèåÌåå! Î∞∞Í≤Ω Î≥ÄÍ≤Ω! üåü`);
                        let newBgIndex; do { newBgIndex = Math.floor(Math.random() * BG_CONFIG.length); } while (newBgIndex === currentBgIndex);
                        updateBackground(newBgIndex);
                    }
                    lastMaxScore = maxScore;

                    if (this.isSuperSmash || this.isFireShot) {
                        shakeDuration = 30; 
                        for(let i=0; i<40; i++) particles.push(new Particle(this.x, this.y, "#FF0000"));
                        charEffects.push(new Shockwave(this.x, this.y, "#FFD700")); 
                    }

                    if (score.p1 >= WIN_SCORE || score.p2 >= WIN_SCORE) {
                        isGameOver = true; gameState = 'gameover';
                        winnerSide = score.p1 >= WIN_SCORE ? 'left' : 'right';
                        winnerName = score.p1 >= WIN_SCORE ? p1.name : p2.name; bgMusic.pause();
                        for(let k=0; k<100; k++) confettis.push(new Confetti());
                    } else {
                        p1.x = 200; p1.y = GROUND_Y - DISPLAY_H; p1.vx=0; p1.vy=0;
                        p2.x = 900; p2.y = GROUND_Y - DISPLAY_H; p2.vx=0; p2.vy=0;
                        this.reset(this.x < 700 ? 'left' : 'right');
                        fakeBalls = [];
                    }
                }
                
                if(this.isFireShot && frameCount % 3 === 0) particles.push(new Particle(this.x, this.y, "#FF4500"));
            }

            draw() {
                if (this.trail.length > 1) {
                    ctx.save();
                    
                    if (this.isFireShot) {
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.lineCap = 'round';
                        for (let i = 0; i < this.trail.length - 1; i++) {
                            const point = this.trail[i];
                            const nextPoint = this.trail[i+1];
                            const ratio = i / this.trail.length;
                            ctx.beginPath();
                            ctx.moveTo(point.x, point.y);
                            ctx.lineTo(nextPoint.x, nextPoint.y);
                            ctx.lineWidth = this.radius * 2 * (ratio + 0.2);
                            if (ratio > 0.8) ctx.strokeStyle = "#FFFFFF"; 
                            else if (ratio > 0.6) ctx.strokeStyle = "#FFFF00";
                            else if (ratio > 0.3) ctx.strokeStyle = "#FF4500";
                            else ctx.strokeStyle = "rgba(255, 0, 0, 0.5)"; 
                            ctx.shadowBlur = 20 * ratio;
                            ctx.shadowColor = "orange";
                            ctx.stroke();
                        }
                    } else if (this.isSuperSmash || this.isRising) {
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.beginPath();
                        ctx.moveTo(this.trail[0].x, this.trail[0].y);
                        for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        
                        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
                        ctx.lineWidth = this.radius * 2.5; 
                        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                        ctx.shadowBlur = 30; ctx.shadowColor = "red";
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(this.trail[0].x, this.trail[0].y);
                        for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.strokeStyle = "rgba(255, 165, 0, 0.7)";
                        ctx.lineWidth = this.radius * 1.5;
                        ctx.stroke();

                    } else {
                        ctx.beginPath();
                        ctx.moveTo(this.trail[0].x, this.trail[0].y);
                        for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.strokeStyle = "rgba(255, 255, 0, 0.3)";
                        ctx.lineWidth = this.radius;
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                if (this.y < GROUND_Y - 20) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.2)"; ctx.beginPath();
                    let shadowSize = Math.max(10, this.radius - (GROUND_Y - this.y) * 0.05);
                    ctx.ellipse(this.x, GROUND_Y - 10, shadowSize, shadowSize * 0.3, 0, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                
                if (ghostBallTimer > 0) {
                    ctx.globalAlpha = 0.15; 
                } else {
                    ctx.globalAlpha = 1.0;
                }

                if (this.isFireShot) {
                    const pulse = Math.sin(Date.now() / 50) * 5; 
                    ctx.fillStyle = "#FFDD00"; 
                    ctx.shadowBlur = 40 + pulse; 
                    ctx.shadowColor = "#FF0000"; 
                }
                else if (this.isSuperSmash || this.isRising || this.isHolding) { 
                    ctx.fillStyle = "#FFFFFF"; 
                    ctx.shadowBlur = 50; ctx.shadowColor = "#FF4500"; 
                }
                else if (this.mushroomCount > 0) { ctx.fillStyle = this.color; ctx.shadowBlur = 0; } 
                else { ctx.fillStyle = this.defaultColor; ctx.shadowBlur = 0; }

                ctx.fill(); ctx.lineWidth = 4; ctx.strokeStyle = "#333"; ctx.stroke(); 
                
                ctx.beginPath(); ctx.arc(this.x - 10, this.y - 10, 8, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255,255,255,0.8)"; ctx.fill(); ctx.shadowBlur = 0; 
                
                ctx.globalAlpha = 1.0;
            }
        }

        // 2. GLOBAL VARIABLES
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreP1 = document.getElementById('scoreP1');
        const scoreP2 = document.getElementById('scoreP2');
        const itemNotice = document.getElementById('item-notice');
        const modeDisplay = document.getElementById('modeDisplay');

        const BG_CONFIG = [
            { src: 'BG.jpg', ballColor: '#FF0055' }, { src: 'BG1.jpg', ballColor: '#FFFF00' },  
            { src: 'BG2.jpg', ballColor: '#00FF00' }, { src: 'BG3.jpg', ballColor: '#FFFFFF' },  
            { src: 'BG4.jpg', ballColor: '#800080' }, { src: 'BG5.jpg', ballColor: '#00FFFF' }
        ];

        let currentBgIndex = Math.floor(Math.random() * BG_CONFIG.length);
        
        const images = {};
        const imageSources = {
            two: 'image/TWO.png', one: 'image/ONE.png', three: 'image/Three.png',
            bg: `image/${BG_CONFIG[currentBgIndex].src}`
        };

        let loadedCount = 0;
        const totalImages = Object.keys(imageSources).length;
        let gameStarted = false;

        function checkAllLoaded() {
            loadedCount++;
            if (loadedCount >= totalImages && !gameStarted) {
                gameStarted = true; initGame(); loop();
            }
        }

        for (const key in imageSources) {
            images[key] = new Image();
            images[key].onload = checkAllLoaded;
            images[key].onerror = () => { console.error(`Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: ${imageSources[key]}`); checkAllLoaded(); };
            images[key].src = imageSources[key];
        }
        
        function updateBackground(index) {
            currentBgIndex = index;
            const newSrc = `image/${BG_CONFIG[currentBgIndex].src}`;
            const tempImg = new Image();
            tempImg.onload = () => { images.bg = tempImg; };
            tempImg.src = newSrc;
            if(ball) ball.defaultColor = BG_CONFIG[currentBgIndex].ballColor;
        }

        const songList = ['song/song.mp3', 'song/song1.mp3', 'song/song2.mp3'];
        const randomSongIndex = Math.floor(Math.random() * songList.length);
        const bgMusic = new Audio(songList[randomSongIndex]); 
        bgMusic.loop = true; bgMusic.volume = 0.4;
        const hitSound = new Audio('song/heavy_punch1.mp3'); 
        hitSound.volume = 0.8;
        // ‚òÖ [Ï†ÄÏä§Ìä∏ Í∞ÄÎìú ÏÇ¨Ïö¥Îìú Ï∂îÍ∞Ä]
        const strikingSound = new Audio('song/striking.mp3');
        strikingSound.volume = 0.9;

        const jumpSound = new Audio('song/jump.mp3');
        const giantSound = new Audio('song/power.mp3');   
        const dwarfSound = new Audio('song/power1.mp3'); 
        const bigBallSound = new Audio('song/power2.mp3'); 
        const coinSound = new Audio('song/coin.mp3');     
        const stampSound = new Audio('song/stamp.mp3');   
        const poopSound = new Audio('song/dong.mp3');     
        const speedSound = new Audio('song/speed.mp3');   
        const iceSound = new Audio('song/cold.mp3');      
        const confusionSound = new Audio('song/confusion.mp3'); 
        const bombSound = new Audio('song/heavy_punch1.mp3'); 
        const windSound = new Audio('song/speed.mp3');        
        const ghostSound = new Audio('song/cold.mp3');        
        const cinematicSound = new Audio('song/power2.mp3'); 

        let blackoutTimer = 0;   
        let typhoonTimer = 0;    
        let windDirection = 0;   
        let ghostBallTimer = 0;
        let wallTimer = 0; 
        let slowMotionTimer = 0; 
        let hitStopTimer = 0;

        let dusts = [];
        let netBend = 0;
        let netBendVel = 0;

        let cinematicTimer = 0;
        let cinematicPlayer = null;

        let CHAR_DB = {}; 
        let GAME_SPEED_RATIO = 1.0; 
        let isVsAI = false; 
        let aiBrain = null;

        function initGame() {
            CHAR_DB = {
                0: { name: "Îã§Ïò®", img: images.two, frames: [0, 1], stats: { speed: 5, jump: -9, power: 1.0 } },
                1: { name: "Ïú†Ï£º", img: images.two, frames: [2, 3], stats: { speed: 5, jump: -9, power: 1.0 } },
                2: { name: "ÏóÑÎßà", img: images.one, frames: [0, 1], stats: { speed: 5, jump: -9, power: 1.0 } },
                3: { name: "ÏïÑÎπ†", img: images.one, frames: [2, 3], stats: { speed: 5, jump: -9, power: 1.0 } },
                4: { name: "ÎèàÍπåÏä§Ìï†Îß§", img: images.three, frames: [0, 1], stats: { speed: 7.5, jump: -10.5, power: 0.9 } },
                5: { name: "Í∑ºÏú°Ìï†Î∞∞", img: images.three, frames: [2, 3], stats: { speed: 3.5, jump: -7.5, power: 1.4 } }
            };
            
            const params = new URLSearchParams(window.location.search);
            const p1Val = params.get('p1') ? parseInt(params.get('p1')) : 0;
            const p2Val = params.get('p2') ? parseInt(params.get('p2')) : 1;
            
            GAME_SPEED_RATIO = params.get('speed') ? parseFloat(params.get('speed')) : 1.0;
            
            isVsAI = params.get('mode') === 'ai';
            if (isVsAI) {
                aiBrain = new AIController();
                modeDisplay.innerText = "MODE: 1 PLAYER (vs CPU)";
                const p2Text = document.getElementById('p2-control-text');
                if(p2Text) {
                    p2Text.innerText = "ü§ñ AI CPU (ÏûêÎèô) ü§ñ";
                    p2Text.style.color = "#00FF00";
                }
            } else {
                modeDisplay.innerText = "MODE: 2 PLAYERS";
                const p2Text = document.getElementById('p2-control-text');
                if(p2Text) {
                    p2Text.innerHTML = '<span class="key-btn">‚Üë</span><span class="key-btn">‚Üê</span><span class="key-btn">‚Üí</span> Ïù¥Îèô + <span class="key-btn" style="border-color:#ff5e62; color:#ff5e62">‚Üì</span> Ïä§Îß§Ïãú';
                }
            }

            p1 = new Player(200, CHAR_DB[p1Val], {up:'KeyW', left:'KeyA', right:'KeyD', down:'KeyS'}, 'left');
            p2 = new Player(900, CHAR_DB[p2Val], {up:'ArrowUp', left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown'}, 'right');
            ball = new Ball();
            ball.defaultColor = BG_CONFIG[currentBgIndex].ballColor;
            ball.color = ball.defaultColor;
            
            startCountdown();
        }

        const GRAVITY = 0.15;       
        const FRICTION = 0.92;
        const DEFAULT_MOVE_SPEED = 5;
        const DEFAULT_JUMP_FORCE = -9;
        const FRAME_W = 960 / 5; const FRAME_H = 192; 
        const DISPLAY_W = 320; const DISPLAY_H = 320;
        const BALL_R = 35;
        const GROUND_Y = 750;
        const WIN_SCORE = 20; 
        
        let score = { p1: 0, p2: 0 };
        let isGameOver = false;
        let winnerName = "";
        let winnerSide = ""; 
        let lastMaxScore = 0; 
        let gameState = 'countdown'; 
        let countdownText = "";
        let rallyCount = 0; 
        
        const keys = {};
        let shakeDuration = 0;
        let particles = [];    
        let charEffects = [];
        let items = [];
        let confettis = []; 
        let reactions = []; 
        let hitTexts = []; 
        let fakeBalls = []; 
        let inkSplotches = []; 
        
        let bigBallTimer = null;
        let frameCount = 0; 
        let p1, p2, ball;

        function startCountdown() {
            gameState = 'countdown';
            countdownText = "3";
            p1.x = 200; p1.y = GROUND_Y - DISPLAY_H; p1.vx=0; p1.vy=0;
            p2.x = 900; p2.y = GROUND_Y - DISPLAY_H; p2.vx=0; p2.vy=0;
            ball.reset('left');

            let count = 3;
            let timer = setInterval(() => {
                count--;
                if (count > 0) { countdownText = count.toString(); } 
                else if (count === 0) { countdownText = "GAME START!"; } 
                else {
                    clearInterval(timer);
                    gameState = 'playing';
                    countdownText = "";
                    bgMusic.play().catch(()=>{});
                }
            }, 1000);
        }

        window.onkeydown = (e) => {
            keys[e.code] = true;
            
            // ‚ñº‚ñº‚ñº Í≤ΩÎ°ú ÏàòÏ†ï (game_select.html -> index.html) ‚ñº‚ñº‚ñº
            if (isGameOver && e.code === 'Enter') window.location.href = 'index.html';

            if (!isGameOver && gameState === 'playing') {
                if (e.code === 'Digit1') p1.setEmoji("üòú");
                if (e.code === 'Digit2') p1.setEmoji("üò°");
                if (e.code === 'Digit3') p1.setEmoji("üò±");
                if (e.code === 'Digit4') p1.setEmoji("üí©");

                if (!isVsAI) {
                    if (e.code === 'KeyM') p2.setEmoji("üòú");
                    if (e.code === 'Comma') p2.setEmoji("üò°");
                    if (e.code === 'Period') p2.setEmoji("üò±");
                    if (e.code === 'Slash') p2.setEmoji("üí©");
                }
            }
        };
        window.onkeyup = (e) => keys[e.code] = false;

        function drawNet() {
            const x = 695; const w = 10; 
            const h = (wallTimer > 0) ? 400 : 200;
            const y = GROUND_Y - h; 

            netBendVel += -0.1 * netBend; 
            netBendVel *= 0.9; 
            netBend += netBendVel;

            ctx.save();
            ctx.fillStyle = "rgba(50, 50, 50, 0.4)";
            
            ctx.beginPath();
            ctx.moveTo(x + netBend, y); 
            ctx.lineTo(x + w + netBend, y);
            ctx.lineTo(x + w, GROUND_Y); 
            ctx.lineTo(x, GROUND_Y);
            ctx.fill();

            ctx.strokeStyle = "rgba(220, 220, 220, 0.8)"; ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = y; i <= GROUND_Y; i += 8) { 
                let progress = 1 - (i - y) / h; 
                let shift = netBend * progress;
                ctx.moveTo(x + shift, i); 
                ctx.lineTo(x + w + shift, i); 
            }
            ctx.moveTo(x + netBend, y); ctx.lineTo(x, GROUND_Y); 
            ctx.moveTo(x + w + netBend, y); ctx.lineTo(x + w, GROUND_Y); 
            ctx.stroke();
            
            if (wallTimer > 0) {
                ctx.shadowBlur = 15; ctx.shadowColor = "gold";
                ctx.fillStyle = "#FFD700";
            } else {
                ctx.shadowBlur = 5; ctx.shadowColor = "rgba(255, 255, 255, 0.5)";
                ctx.fillStyle = "#fff";
            }
            
            ctx.beginPath();
            ctx.moveTo(x - 2 + netBend, y);
            ctx.lineTo(x + w + 2 + netBend, y);
            ctx.lineTo(x + w + 2 + netBend * 0.9, y + 12);
            ctx.lineTo(x - 2 + netBend * 0.9, y + 12);
            ctx.fill();

            ctx.restore();
        }

        function createExplosion(x, y, color) { for(let i=0; i<12; i++) particles.push(new Particle(x, y, color)); }
        function createCharEffect(x, y, color) { charEffects.push(new Shockwave(x, y, color)); }
        function showItemNotice(text) { itemNotice.innerText = text; itemNotice.style.opacity = 1; setTimeout(() => { itemNotice.style.opacity = 0; }, 2000); }

        function triggerFireShotSequence(player, ball) {
            if (ball.isRising || ball.isHolding) return;

            ball.fireShooter = player;
            ball.isRising = true; 
            ball.isSuperSmash = false; 
            ball.vx = 0; 
            ball.vy = -20; 

            showItemNotice("üî• ÌïÑÏÇ¥Í∏∞ Î∞úÎèô! üî•");
            createExplosion(player.x, player.y, "#FF0000");
        }

        function fireScatterShot(ball) {
            const player = ball.fireShooter;
            if (!player) return;

            showItemNotice("‚òÑÔ∏è METEOR STORM! ‚òÑÔ∏è");
            shakeDuration = 60; 

            charEffects.push(new Shockwave(ball.x, ball.y, "#FF0000"));
            charEffects.push(new Shockwave(ball.x, ball.y, "#FFFF00"));

            const startX = player.side === 'left' ? 700 : 700;
            const endX = player.side === 'left' ? 1400 : 0;
            const courtWidth = Math.abs(endX - startX);
            const gap = courtWidth / 6;
            const realBallIndex = 2; 

            for(let i = 0; i < 5; i++) {
                let targetX;
                if (player.side === 'left') { targetX = 700 + (gap * (i + 1)); } 
                else { targetX = 700 - (gap * (i + 1)); }

                const timeToHit = 30; 
                const targetY = 750;
                
                const vx = (targetX - ball.x) / timeToHit;
                const vy = (targetY - ball.y) / timeToHit - (0.5 * (GRAVITY * ball.mass) * timeToHit);

                if (i === realBallIndex) {
                    ball.vx = vx * GAME_SPEED_RATIO;
                    ball.vy = vy * GAME_SPEED_RATIO;
                    ball.isFireShot = true; 
                } else {
                    let fb = new FakeBall(ball.x, ball.y, "#FF4500");
                    fb.vx = vx * GAME_SPEED_RATIO;
                    fb.vy = vy * GAME_SPEED_RATIO;
                    fakeBalls.push(fb);
                }
            }
            createExplosion(ball.x, ball.y, "#FFFFFF");
        }

        function checkHit(p, b) {
            if (gameState !== 'playing') return;
            if (cinematicTimer > 0) return; 

            let hitCenterX = p.x + DISPLAY_W/2;
            let hitCenterY = p.y + DISPLAY_H/2;
            
            if (p.chickenTimer > 0) {
                const distLeft = Math.abs((p.x + DISPLAY_W/2 - 70) - b.x);
                const distCenter = Math.abs((p.x + DISPLAY_W/2) - b.x);
                const distRight = Math.abs((p.x + DISPLAY_W/2 + 70) - b.x);
                const minDist = Math.min(distLeft, distCenter, distRight);
                if (minDist === distLeft) hitCenterX -= 70;
                else if (minDist === distRight) hitCenterX += 70;
            }

            let dx = hitCenterX - b.x; 
            let dy = hitCenterY - b.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < DISPLAY_W/2 + b.radius) { 
                
                // ‚òÖ [2. Ï†ÄÏä§Ìä∏ Í∞ÄÎìú ÏãúÏä§ÌÖú]
                // ÏÉÅÎåÄÎ∞©Ïùò Í∞ïÎ†•Ìïú Í≥µÍ≤©(ÏäàÌçºÏä§Îß§Ïãú, Î∂àÍΩÉÏäõ)Ïù¥ Îì§Ïñ¥Ïò¨ Îïå
                if (b.isSuperSmash || b.isFireShot || (Math.abs(b.vx) > 15)) {
                    // ÌÇ§Î•º ÎàÑÎ•¥Í≥† ÏûàÎäî ÏÉÅÌÉúÏóêÏÑú Ï∂©ÎèåÌïòÎ©¥ 'Ï†ÄÏä§Ìä∏ Í∞ÄÎìú' ÌåêÏ†ï
                    if (keys[p.controls.down]) {
                        b.isSuperSmash = false;
                        b.isFireShot = false;
                        
                        // Í≥µ Î∞òÏÇ¨ (Reflect)
                        b.vx = p.side === 'left' ? 25 : -25;
                        b.vy = -15;

                        // Ïù¥ÌéôÌä∏ Î∞è ÏÇ¨Ïö¥Îìú
                        createExplosion(b.x, b.y, "#00FFFF"); // Ï≤≠ÏÉâ Ìè≠Î∞ú
                        charEffects.push(new Shockwave(b.x, b.y, "#00FFFF"));
                        strikingSound.currentTime = 0; strikingSound.play().catch(()=>{});
                        
                        hitStopTimer = 10; // ÏûÑÌå©Ìä∏ Ï†ïÏßÄ
                        shakeDuration = 10;
                        
                        // Í≤åÏù¥ÏßÄ Î≥¥ÎÑàÏä§
                        p.gauge = Math.min(p.gauge + 30, p.maxGauge);
                        showItemNotice("üõ°Ô∏è JUST GUARD! üõ°Ô∏è");
                        return; // ÏùºÎ∞ò ÌîºÍ≤© Î°úÏßÅ Î¨¥Ïãú
                    } else {
                        // Î∞©Ïñ¥ Ïã§Ìå® Ïãú (Í∏∞Ï°¥ Î°úÏßÅ)
                        p.stunTimer = 60; 
                        p.isSmashHit = true; 
                        p.vx = p.side === 'left' ? -20 : 20; 
                        createExplosion(p.x + DISPLAY_W/2, p.y + DISPLAY_H/2, "red");
                        showItemNotice("üí• Îö´Î†∏Îã§!! üí•");
                        bombSound.play().catch(()=>{});
                        return;
                    }
                }

                hitSound.currentTime = 0; hitSound.play().catch(()=>{});
                rallyCount++;
                if(rallyCount >= 3) { showItemNotice(`üî• ${rallyCount} Combo! üî•`); }

                const effectColor = p.side === 'left' ? '#00d2ff' : '#ff5e62';
                createCharEffect(p.x + DISPLAY_W/2, p.y + DISPLAY_H/2, effectColor);
                b.vy = -9 * GAME_SPEED_RATIO; 
                b.vx = (b.x - hitCenterX) * 0.09 * GAME_SPEED_RATIO; 
                
                const randomWords = ["POW!", "BAM!", "HIT!", "SMASH!", "BANG!"];
                const text = randomWords[Math.floor(Math.random() * randomWords.length)];
                hitTexts.push(new HitText(b.x, b.y - 50, text, effectColor));

                if (keys[p.controls.down] && p.gauge >= 100) { 
                    startCinematicSmash(p, b, p.isJumping);
                    return; 
                }

                p.gauge = Math.min(p.gauge + 15, p.maxGauge);

                if (p.name === "ÎèàÍπåÏä§Ìï†Îß§") { for(let i=0; i<8; i++) particles.push(new Particle(b.x, b.y, "#FF4500")); createExplosion(b.x, b.y, "#FFD700"); }
                
                if (keys[p.controls.down]) { 
                    if (p.fireMultiBallTimer > 0) {
                         triggerFireShotSequence(p, b);
                         return;
                    }

                    hitStopTimer = 6; 
                    shakeDuration = 20; 
                    b.isFireShot = false; 
                    b.vx = ((p.side === 'left' ? 13 : -13) * p.power) * GAME_SPEED_RATIO; 
                    b.vy = 6 * GAME_SPEED_RATIO; 
                    createExplosion(b.x, b.y, "#FFD700"); 
                } else { 
                    b.isFireShot = false; 
                    createExplosion(b.x, b.y, "rgba(255, 255, 255, 0.5)"); 
                }
                b.isSuperSmash = false;
            }
        }

        function startCinematicSmash(player, ballObj, isJump) {
            cinematicTimer = 60; 
            cinematicPlayer = player;
            player.gauge = 0; 
            player.isJumpSmash = isJump;
            cinematicSound.currentTime = 0; cinematicSound.play().catch(()=>{});
        }

        function executeSuperSmash(player, ballObj) {
            if (player.fireMultiBallTimer > 0) {
                triggerFireShotSequence(player, ballObj);
                return;
            }

            ballObj.isSuperSmash = true;
            shakeDuration = 60; 
            
            createExplosion(ballObj.x, ballObj.y, "#FF0000");
            createExplosion(ballObj.x, ballObj.y, "#FFFF00");
            createCharEffect(ballObj.x, ballObj.y, "#FFFFFF");

            ballObj.smashStart = { x: ballObj.x, y: ballObj.y };
            let targetX = player.side === 'left' ? 1320 : 80;
            ballObj.smashEnd = { x: targetX, y: 750 }; 
            ballObj.smashControl = { x: 700, y: -350 }; 
            ballObj.smashTimer = 0;
            ballObj.smashDuration = 35 / GAME_SPEED_RATIO; 
            
            if (player.isJumpSmash) {
                ballObj.radius = 20;
                for(let i=0; i<50; i++) {
                    let px = player.x + DISPLAY_W/2; 
                    let py = player.y + DISPLAY_H/2;
                    let p = new Particle(px, py, i % 2 === 0 ? "#FF4500" : "#FFFF00");
                    p.vx *= 2; 
                    p.vy *= 2;
                    particles.push(p); 
                }
                ballObj.color = "#FFF"; 
                showItemNotice(`‚ö° ULTRA SUPER SMASH!!! ‚ö°`);
            } else {
                showItemNotice(`‚ö° SUPER SMASH!!! ‚ö°`);
            }
        }

        function checkItemCollection(player) {
            items.forEach(item => { if (!item.active) return; let px = player.x + DISPLAY_W/2; let py = player.y + DISPLAY_H/2; let dx = px - item.x; let dy = py - item.y; if (Math.sqrt(dx*dx + dy*dy) < 80) { item.active = false; applyItemEffect(player, item); } });
        }

        function applyItemEffect(player, item) {
            const type = item.type;
            const opponent = player.side === 'left' ? p2 : p1;

            if (type === 'SPEED') { 
                speedSound.play().catch(()=>{});
                player.moveSpeed = player.baseSpeed * 2; showItemNotice(`‚ö° ${player.name} Ïä§ÌîºÎìú ÏóÖ! ‚ö°`); setTimeout(() => { player.moveSpeed = player.baseSpeed; }, 8000); 
            } 
            else if (type === 'JUMP') { 
                player.jumpForce = player.baseJumpForce * 1.5; 
                player.hasJumpBuff = true; 
                showItemNotice(`üöÄ ${player.name} ÏäàÌçº Ï†êÌîÑ! üöÄ`); 
                setTimeout(() => { 
                    player.jumpForce = player.baseJumpForce; 
                    player.hasJumpBuff = false; 
                }, 8000); 
            } 
            else if (type === 'BIG') {
                if (bigBallTimer) clearTimeout(bigBallTimer);
                ball.mushroomCount++;
                bigBallSound.play().catch(()=>{}); 
                if (ball.mushroomCount === 1) { ball.radius = 70; ball.mass = 1.3; ball.color = "#FF7F50"; showItemNotice("üèê Í≥µÏù¥ Ïª§Ï°åÎã§! (2Î∞∞) üèê"); }
                else if (ball.mushroomCount >= 2) { ball.radius = 105; ball.mass = 1.6; ball.color = "#FF4500"; showItemNotice("üèêüèê ÏóÑÏ≤≠ Ïª§Ï°åÎã§! (3Î∞∞) üèêüèê"); }
                if (ball.mushroomCount > 0) { bigBallTimer = setTimeout(() => { ball.radius = BALL_R; ball.mass = 1; ball.color = ball.defaultColor; ball.mushroomCount = 0; }, 10000); }
            } 
            else if (type === 'BONUS') { 
                coinSound.play().catch(()=>{}); 
                if (player.side === 'left') { score.p1++; scoreP1.innerText = score.p1; } else { score.p2++; scoreP2.innerText = score.p2; } showItemNotice("üíé Î≥¥ÎÑàÏä§ Ï†êÏàò! üíé"); 
            }
            else if (type === 'BANANA') { 
                stampSound.play().catch(()=>{}); 
                player.stunTimer = 90; showItemNotice(`üçå ${player.name} ÎØ∏ÎÅÑÎü¨Ïßê! üçå`); 
            }
            else if (type === 'POOP') { 
                poopSound.play().catch(()=>{}); 
                player.poopTimer = 180; showItemNotice(`üí© ${player.name} Îò• Î∞üÏùå! üí©`); 
            }
            else if (type === 'GIANT') { 
                giantSound.play().catch(()=>{}); 
                player.scale = 2.0; showItemNotice(`üçÑ ${player.name} Í±∞ÎåÄÌôî! üçÑ`); setTimeout(() => { player.scale = 1.0; }, 8000); 
            }
            else if (type === 'DWARF') { 
                dwarfSound.play().catch(()=>{}); 
                opponent.scale = 0.5; showItemNotice(`üë∂ ${opponent.name} ÏûëÏïÑÏßê! üë∂`); setTimeout(() => { opponent.scale = 1.0; }, 8000); 
            }
            else if (type === 'ICE') {
                iceSound.play().catch(()=>{}); 
                opponent.frozenTimer = 120; 
                showItemNotice(`‚ùÑÔ∏è ${opponent.name} ÍΩÅÍΩÅ ÏñºÏùå! ‚ùÑÔ∏è`);
            }
            else if (type === 'CONFUSION') {
                confusionSound.play().catch(()=>{}); 
                opponent.confusedTimer = 180; 
                showItemNotice(`üòµ ${opponent.name} Ïñ¥ÏßàÏñ¥Ïßà~ üòµ`);
            }
            else if (type === 'BOMB') {
                bombSound.play().catch(()=>{});
                player.stunTimer = 120; 
                player.vy = -15; 
                createExplosion(player.x + DISPLAY_W/2, player.y + DISPLAY_H/2, "red");
                showItemNotice(`üí£ ${player.name} Ìè≠Î∞ú!!! üí£`);
            }
            else if (type === 'BLACKOUT') {
                blackoutTimer = 300; 
                showItemNotice(`üåë Ï†ïÏ†Ñ Î∞úÏÉù! ÏïûÏù¥ Ïïà Î≥¥Ïó¨! üåë`);
            }
            else if (type === 'TYPHOON') {
                windSound.play().catch(()=>{});
                typhoonTimer = 400; 
                windDirection = Math.random() < 0.5 ? -1 : 1; 
                const dirText = windDirection < 0 ? "<<< ÏÑúÌíç" : "ÎèôÌíç >>>";
                showItemNotice(`üå™Ô∏è ÌÉúÌíç Î∞úÏÉù! (${dirText}) üå™Ô∏è`);
            }
            else if (type === 'GHOST') {
                ghostSound.play().catch(()=>{});
                ghostBallTimer = 400; 
                showItemNotice(`üëª Í≥µÏù¥ Ïú†Î†πÏúºÎ°ú Î≥ÄÌñàÎã§! üëª`);
            }
            else if (type === 'INK') {
                bombSound.play().catch(()=>{}); 
                for(let i=0; i<5; i++) inkSplotches.push(new InkSplotch());
                showItemNotice(`ü¶ë Î®πÎ¨º ÎøåÎ¶¨Í∏∞! ü¶ë`);
            }
            else if (type === 'CLONE') {
                ghostSound.play().catch(()=>{}); 
                for(let i=0; i<4; i++) {
                    let fb = new FakeBall(ball.x, ball.y, ball.color);
                    fb.vx = ball.vx + (Math.random() - 0.5) * 4; 
                    fb.vy = ball.vy + (Math.random() - 0.5) * 4;
                    fakeBalls.push(fb);
                }
                showItemNotice(`ü§• Î∂ÑÏã†Ïà† ÎåÄÏÜåÎèô! (ÏßÑÏßúÎ•º Ï∞æÏïÑÎùº!) ü§•`);
            }
            else if (type === 'WALL') {
                giantSound.play().catch(()=>{}); 
                wallTimer = 600; 
                showItemNotice(`üß± Ï≤†Î≤Ω Î∞©Ïñ¥! ÎÑ§Ìä∏ ÏÉÅÏäπ! üß±`);
            }
            else if (type === 'CHICKEN') {
                giantSound.play().catch(()=>{}); 
                player.chickenTimer = 1200; 
                showItemNotice(`üêî Íº¨Íº¨ÎåÅ Íµ∞Îã®! (3ÎßàÎ¶¨!) üêî`);
            }
            else if (type === 'FIRE') {
                giantSound.play().catch(()=>{});
                player.fireMultiBallTimer = 600; // 10Ï¥à
                showItemNotice(`üî• Î∂àÍΩÉ ÏïÑÏù¥ÌÖú ÌöçÎìù! (SÌÇ§: ÌïÑÏÇ¥Í∏∞) üî•`);
            }
        }

        function resetGame() {
            score.p1 = 0; score.p2 = 0;
            scoreP1.innerText = 0; scoreP2.innerText = 0;
            lastMaxScore = 0; rallyCount = 0;
            isGameOver = false; ball.reset('left'); items = [];
            p1.moveSpeed = p1.baseSpeed; p1.gauge = 0; p1.scale = 1; p1.angle = 0; p1.stunTimer = 0; p1.poopTimer = 0; p1.hasJumpBuff = false; p1.frozenTimer = 0; p1.confusedTimer = 0;
            
            blackoutTimer = 0;
            typhoonTimer = 0;
            ghostBallTimer = 0;
            cinematicTimer = 0;
            
            wallTimer = 0;
            slowMotionTimer = 0;
            p1.chickenTimer = 0;
            p2.chickenTimer = 0;
            inkSplotches = [];
            fakeBalls = [];
            hitStopTimer = 0;
            dusts = [];
            netBend = 0;
            netBendVel = 0;
            // Î¶¨ÏÖã
            p1.fireMultiBallTimer = 0;
            p2.fireMultiBallTimer = 0;

            bgMusic.currentTime = 0; bgMusic.play();
            bgMusic.playbackRate = 1.0; 

            if (bigBallTimer) clearTimeout(bigBallTimer);
            startCountdown();
        }

        function loop() {
            frameCount++;
            
            if (isVsAI && aiBrain && gameState === 'playing' && cinematicTimer <= 0) {
                const currentNetHeight = (wallTimer > 0) ? 400 : 200;
                aiBrain.update(p2, ball, currentNetHeight);
            }

            if (cinematicTimer === 0) {
                if (!isGameOver && Math.random() < 0.003) items.push(new Item());
                if (blackoutTimer > 0) blackoutTimer--;
                if (typhoonTimer > 0) typhoonTimer--;
                if (ghostBallTimer > 0) ghostBallTimer--;
                if (wallTimer > 0) wallTimer--; 
            }

            if (hitStopTimer > 0) {
                hitStopTimer--;
            }

            // [Ïπ¥Î©îÎùº ÏóÖÎç∞Ïù¥Ìä∏]
            if(gameStarted) {
                camera.update(ball);
            }

            let shakeX = 0; let shakeY = 0;
            if (shakeDuration > 0) { shakeX = (Math.random() - 0.5) * 10; shakeY = (Math.random() - 0.5) * 10; shakeDuration--; }
            
            // ‚òÖ [Ïπ¥Î©îÎùº Ï†ÅÏö© ÏãúÏûë]
            // ÌôîÎ©¥ Ï†ÑÏ≤¥Î•º ÏßÄÏõÅÎãàÎã§.
            ctx.clearRect(0, 0, 1400, 800);
            ctx.save(); 
            ctx.translate(shakeX, shakeY); // ÏâêÏù¥ÌÅ¨ Ï†ÅÏö©
            camera.apply(ctx); // Ïπ¥Î©îÎùº Ï§å/Ïù¥Îèô Ï†ÅÏö©
            
            if (images.bg && images.bg.complete) { ctx.drawImage(images.bg, 0, 0, 1400, 800); } 
            else { ctx.fillStyle = "#1e3c72"; ctx.fillRect(0, 0, 1400, 800); }
            ctx.fillStyle = "rgba(230, 200, 150, 0.8)"; ctx.fillRect(0, 750, 1400, 50);
            
            drawNet();

            if ((score.p1 === WIN_SCORE - 1 || score.p2 === WIN_SCORE - 1) && !isGameOver) {
                if (bgMusic.playbackRate === 1.0) bgMusic.playbackRate = 1.3;

                const centerX = ball.x;
                const centerY = ball.y;
                const gradient = ctx.createRadialGradient(centerX, centerY, 100, centerX, centerY, 800);
                gradient.addColorStop(0, "rgba(0,0,0,0)");
                gradient.addColorStop(0.2, "rgba(0,0,0,0.3)");
                gradient.addColorStop(1, "rgba(0,0,0,0.85)"); 
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 1400, 800);
            } else {
                if (!isGameOver && bgMusic.playbackRate !== 1.0) bgMusic.playbackRate = 1.0;
            }

            let doUpdate = true;
            if (slowMotionTimer > 0) {
                slowMotionTimer--;
                if (frameCount % 3 !== 0) doUpdate = false; 
            }
            if (hitStopTimer > 0) doUpdate = false;

            for (let i = dusts.length - 1; i >= 0; i--) {
                if(doUpdate) dusts[i].update();
                dusts[i].draw();
                if (dusts[i].life <= 0) dusts.splice(i, 1);
            }

            for (let i = charEffects.length - 1; i >= 0; i--) { if(doUpdate) charEffects[i].update(); charEffects[i].draw(); if (charEffects[i].alpha <= 0) charEffects.splice(i, 1); }
            for (let i = particles.length - 1; i >= 0; i--) { if(doUpdate) particles[i].update(); particles[i].draw(); if (particles[i].life <= 0) particles.splice(i, 1); }
            for (let i = items.length - 1; i >= 0; i--) { if(doUpdate) items[i].update(); items[i].draw(); if (!items[i].active) items.splice(i, 1); }
            for (let i = confettis.length - 1; i >= 0; i--) { if(doUpdate) confettis[i].update(); confettis[i].draw(); }
            for (let i = reactions.length - 1; i >= 0; i--) { if(doUpdate) reactions[i].update(); reactions[i].draw(); if(reactions[i].life<=0) reactions.splice(i,1); }
            for (let i = hitTexts.length - 1; i >= 0; i--) { if(doUpdate) hitTexts[i].update(); hitTexts[i].draw(); if(hitTexts[i].life<=0) hitTexts.splice(i,1); }

            for (let i = fakeBalls.length - 1; i >= 0; i--) { 
                if(doUpdate) fakeBalls[i].update(); 
                fakeBalls[i].draw(); 
                if (!fakeBalls[i].active) fakeBalls.splice(i, 1); 
            }

            if(gameStarted) {
                if (doUpdate) {
                    p1.update(); p2.update(); ball.update();
                    checkHit(p1, ball); checkHit(p2, ball);
                    checkItemCollection(p1); checkItemCollection(p2); 
                }
                p1.draw(); p2.draw(); ball.draw();
            }
            
            if (blackoutTimer > 0) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.92)"; 
                ctx.fillRect(0, 0, 1400, 800);
                if (Math.floor(Date.now() / 500) % 2 === 0) {
                    ctx.font = "50px 'Black Han Sans'"; ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.fillText("‚ö†Ô∏è Ï†ïÏ†Ñ Î∞úÏÉù! ‚ö†Ô∏è", 700, 400);
                }
            }

            for (let i = inkSplotches.length - 1; i >= 0; i--) {
                if(doUpdate) inkSplotches[i].update();
                inkSplotches[i].draw();
                if (inkSplotches[i].life <= 0) inkSplotches.splice(i, 1);
            }
            
            if (cinematicTimer > 0) {
                cinematicTimer--;
                
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(0, 0, 1400, 800);
                
                ctx.save();
                ctx.translate(cinematicPlayer.x + DISPLAY_W/2, cinematicPlayer.y + DISPLAY_H/2);
                for(let i=0; i<10; i++) {
                    ctx.rotate(Math.random() * Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
                    ctx.fillRect(50, -2, 800, 4);
                }
                ctx.restore();

                ctx.save();
                const scale = 1 + (60 - cinematicTimer) / 20; 
                ctx.translate(700, 400); ctx.scale(scale, scale);
                ctx.font = "bold 80px 'Black Han Sans'";
                ctx.fillStyle = "#00FFFF"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.shadowColor = "blue"; ctx.shadowBlur = 30;
                ctx.fillText("SUPER SMASH!!", 0, 0);
                ctx.strokeStyle = "white"; ctx.lineWidth = 4; ctx.strokeText("SUPER SMASH!!", 0, 0);
                ctx.restore();

                if (cinematicTimer <= 0) {
                    executeSuperSmash(cinematicPlayer, ball);
                }
            }

            // ‚òÖ [Ïπ¥Î©îÎùº Ï†ÅÏö© ÎÅù - UIÎäî Ï§åÏù∏ ÎêòÏßÄ ÏïäÍ≤å Ïó¨Í∏∞ÏÑú restore]
            ctx.restore();

            if (gameState === 'countdown' && countdownText !== "") {
                ctx.save();
                ctx.shadowColor = "black"; ctx.shadowBlur = 20;
                ctx.font = "bold 150px 'Black Han Sans', sans-serif";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                if(countdownText === "3") ctx.fillStyle = "#ff5e62";
                else if(countdownText === "2") ctx.fillStyle = "orange";
                else if(countdownText === "1") ctx.fillStyle = "#00d2ff";
                else ctx.fillStyle = "#FFFF00"; 
                ctx.fillText(countdownText, 700, 350);
                ctx.lineWidth = 5; ctx.strokeStyle = "white"; ctx.strokeText(countdownText, 700, 350);
                ctx.restore();
            }

            if (!isGameOver && (score.p1 === WIN_SCORE - 1 || score.p2 === WIN_SCORE - 1) && gameState === 'playing') {
                ctx.save();
                const scale = 1 + Math.sin(Date.now() / 200) * 0.1;
                ctx.translate(700, 150); ctx.scale(scale, scale);
                ctx.font = "bold 60px 'Black Han Sans', sans-serif";
                ctx.textAlign = "center"; ctx.fillStyle = "#FF0000";
                ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
                ctx.fillText("üî• MATCH POINT üî•", 0, 0);
                ctx.restore();
            }

            if (isGameOver) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)"; ctx.fillRect(0, 0, 1400, 800);
                ctx.save();
                const blink = Math.floor(Date.now() / 200) % 2; 
                ctx.fillStyle = blink === 0 ? "#FFD700" : "#FFFFFF"; 
                ctx.font = "bold 100px 'Black Han Sans', sans-serif";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.shadowColor = "orange"; ctx.shadowBlur = 30;
                ctx.fillText(`${winnerName} ÏäπÎ¶¨! üéâ`, 700, 350);
                ctx.shadowBlur = 0; ctx.fillStyle = "white";
                ctx.font = "bold 30px 'Black Han Sans', sans-serif";
                ctx.fillText("Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÎ†§Î©¥ Enter", 700, 500);
                ctx.restore();
            }
            requestAnimationFrame(loop);
        }
        
        setTimeout(() => {
            if(!gameStarted) {
                console.warn("Ïù¥ÎØ∏ÏßÄ Î°úÎî© ÏãúÍ∞Ñ Ï¥àÍ≥º ÎòêÎäî Ïã§Ìå®. Í≤åÏûÑÏùÑ Í∞ïÏ†úÎ°ú ÏãúÏûëÌï©ÎãàÎã§.");
                gameStarted = true; initGame(); loop();
            }
        }, 3000);

    </script>
</body>
</html>